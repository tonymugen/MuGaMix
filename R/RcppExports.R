# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

tstMissMat <- function(vec, Nrow, Ncol) {
    .Call(`_MuGaMix_tstMissMat`, vec, Nrow, Ncol)
}

testLpostNR <- function(yVec, d, Npop, theta, P, ind, limit, incr) {
    .Call(`_MuGaMix_testLpostNR`, yVec, d, Npop, theta, P, ind, limit, incr)
}

testLpostP <- function(yVec, d, Npop, theta, Phi, ind, limit, incr) {
    .Call(`_MuGaMix_testLpostP`, yVec, d, Npop, theta, Phi, ind, limit, incr)
}

testLpostLocNR <- function(yVec, d, Npop, theta, iSigTheta, ind, limit, incr) {
    .Call(`_MuGaMix_testLpostLocNR`, yVec, d, Npop, theta, iSigTheta, ind, limit, incr)
}

testGradNR <- function(yVec, d, Npop, theta, P, ind, limit, incr) {
    .Call(`_MuGaMix_testGradNR`, yVec, d, Npop, theta, P, ind, limit, incr)
}

testGradP <- function(yVec, d, Npop, theta, Phi, ind, limit, incr) {
    .Call(`_MuGaMix_testGradP`, yVec, d, Npop, theta, Phi, ind, limit, incr)
}

testGradLocNR <- function(yVec, d, Npop, theta, iSigTheta, ind, limit, incr) {
    .Call(`_MuGaMix_testGradLocNR`, yVec, d, Npop, theta, iSigTheta, ind, limit, incr)
}

testLpostSigNR <- function(yVec, d, Npop, theta, iSigTheta, ind, limit, incr) {
    .Call(`_MuGaMix_testLpostSigNR`, yVec, d, Npop, theta, iSigTheta, ind, limit, incr)
}

testLpostLoc <- function(yVec, lnFac, Npop, theta, iSigTheta) {
    .Call(`_MuGaMix_testLpostLoc`, yVec, lnFac, Npop, theta, iSigTheta)
}

lpTestLI <- function(yVec, lnFac, Npop, theta, iSigTheta, ind, limit, incr) {
    .Call(`_MuGaMix_lpTestLI`, yVec, lnFac, Npop, theta, iSigTheta, ind, limit, incr)
}

gradTestLI <- function(yVec, lnFac, Npop, theta, iSigTheta, ind, limit, incr) {
    .Call(`_MuGaMix_gradTestLI`, yVec, lnFac, Npop, theta, iSigTheta, ind, limit, incr)
}

lpTestSI <- function(yVec, lnFac, Npop, theta, iSigTheta, ind, limit, incr) {
    .Call(`_MuGaMix_lpTestSI`, yVec, lnFac, Npop, theta, iSigTheta, ind, limit, incr)
}

gradTestSInr <- function(yVec, d, Npop, theta, iSigTheta, ind, limit, incr) {
    .Call(`_MuGaMix_gradTestSInr`, yVec, d, Npop, theta, iSigTheta, ind, limit, incr)
}

gradTestSI <- function(yVec, lnFac, Npop, theta, iSigTheta, ind, limit, incr) {
    .Call(`_MuGaMix_gradTestSI`, yVec, lnFac, Npop, theta, iSigTheta, ind, limit, incr)
}

#' Variational Bayes model fit
#'
#' Fits a Gaussian mixture model using variational Bayes. Assumes no missing data.
#'
#' @param yVec    vectorized data matrix
#' @param d       number of traits
#' @param nPop    number of populations
#' @param alphaPr prior population size
#' @param sigSqPr prior variance
#' @param ppRatio population to error covariance ratio
#' @param nReps   number of model fit attempts before picking the best fit
#' @return list containing population means (\code{popMeans}), covariances (\code{covariances}), effective population sizes (\code{effNm}), population assignment probabilities (\code{p}), and the deviance information criterion (DIC, \code{DIC}).
#'
#' @keywords internal
#'
vbFit <- function(yVec, d, nPop, alphaPr, sigSqPr, ppRatio, nReps) {
    .Call(`_MuGaMix_vbFit`, yVec, d, nPop, alphaPr, sigSqPr, ppRatio, nReps)
}

#' Variational Bayes model fit with missing data
#'
#' Fits a Gaussian mixture model using variational Bayes. Allows missing data. Missing values are marked with an integer vector that stores base-0 indexes of the messing values in the vectorized data matrix.
#'
#' @param yVec    vectorized data matrix
#' @param missInd missing values indexes (base-0)
#' @param d       number of traits
#' @param nPop    number of populations
#' @param alphaPr prior population size
#' @param sigSqPr prior variance
#' @param ppRatio population to error covariance ratio
#' @param nReps   number of model fit attempts before picking the best fit
#' @return list containing population means (\code{popMeans}), covariances (\code{covariances}), effective population sizes (\code{effNm}), population assignment probabilities (\code{p}), and the deviance information criterion (DIC, \code{DIC}).
#'
#' @keywords internal
#'
vbFitMiss <- function(yVec, missInd, d, nPop, alphaPr, sigSqPr, ppRatio, nReps) {
    .Call(`_MuGaMix_vbFitMiss`, yVec, missInd, d, nPop, alphaPr, sigSqPr, ppRatio, nReps)
}

#' Run the sampler with no replication
#'
#' Runs the sampler on the data assuming no fixed effects, missing trait data, or replication.
#'
#' @param yVec   vectorized data matrix
#' @param d      number of traits
#' @param Npop   number of populations
#' @param Nadapt number of adaptation (burn-in) steps
#' @param Nsamp  number of sampling steps
#' @param Nthin  thinning number
#'
#' @keywords internal
#'
runSamplerNR <- function(yVec, d, Npop, Nadapt, Nsamp, Nthin, Nchains) {
    .Call(`_MuGaMix_runSamplerNR`, yVec, d, Npop, Nadapt, Nsamp, Nthin, Nchains)
}

#' Run the sampler with one replication level
#'
#' Runs the sampler on the data assuming no fixed effects or missing trait data and one replication level.
#'
#' @param yVec vectorized data matrix
#' @param lnFac factor relating data points to lines
#' @param Npop number of populations
#' @param Nadapt number of adaptation (burn-in) steps
#' @param Nsamp number of sampling steps
#' @param Nthin thinning number
#'
#' @keywords internal
#'
runSampler <- function(yVec, lnFac, Npop, Nadapt, Nsamp, Nthin, Nchains) {
    .Call(`_MuGaMix_runSampler`, yVec, lnFac, Npop, Nadapt, Nsamp, Nthin, Nchains)
}

#' Run the sampler with missing data and one replication level
#'
#' Runs the sampler on the data assuming no fixed effects, but allowing for missing phenotype data, and one replication level.
#' The missingness indicator should have 1 for missing data points and 0 otherwise, however any non-0 value is treated as 1.
#'
#' @param yVec vectorized data matrix
#' @param lnFac factor relating data points to lines
#' @param missIDs vectorized matrix (same dimensions as data) with 1 where a data point is missing and 0 otherwise
#' @param Npop number of populations
#' @param Nadapt number of adaptation (burn-in) steps
#' @param Nsamp number of sampling steps
#' @param Nthin thinning number
#'
#' @keywords internal
#'
runSamplerMiss <- function(yVec, lnFac, missIDs, Npop, Nadapt, Nsamp, Nthin, Nchains) {
    .Call(`_MuGaMix_runSamplerMiss`, yVec, lnFac, missIDs, Npop, Nadapt, Nsamp, Nthin, Nchains)
}

